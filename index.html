<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fly Catcher</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    #game-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <script>
// ============================================
// FLY CATCHER - v2 with Levels
// ============================================

const CONFIG = {
  width: 390,
  height: 700
};

const LEVELS = {
  1: {
    name: 'Fly Swatter',
    tool: 'swatter',
    targetCatches: 10,
    timeLimit: 30,
    flySpeed: 2.5,
    hitRadius: 100,
    maxFlies: 1,
    instructions: 'Tap to swat!'
  },
  2: {
    name: 'Rubber Band',
    tool: 'rubberband',
    targetCatches: 10,
    timeLimit: 60,
    flySpeed: 3.5,
    hitRadius: 25,
    maxFlies: 1,
    instructions: 'Pull back & release to shoot!'
  }
};

// ============================================
// FLY CLASS - Realistic behavior
// ============================================
class Fly {
  constructor(scene, x, y, speed) {
    this.scene = scene;
    this.alive = true;
    this.maxSpeed = speed || 2.5;
    
    // Create fly graphics
    this.container = scene.add.container(x, y);
    
    // Body
    this.body = scene.add.ellipse(0, 0, 20, 14, 0x222222);
    
    // Wings
    this.leftWing = scene.add.ellipse(-8, -2, 14, 8, 0x88888888);
    this.rightWing = scene.add.ellipse(8, -2, 14, 8, 0x88888888);
    this.leftWing.setAngle(-20);
    this.rightWing.setAngle(20);
    
    // Eyes (flies have near 360Â° vision)
    this.leftEye = scene.add.circle(-4, -4, 4, 0xcc0000);
    this.rightEye = scene.add.circle(4, -4, 4, 0xcc0000);
    
    this.container.add([this.leftWing, this.rightWing, this.body, this.leftEye, this.rightEye]);
    
    // Movement properties
    this.velocity = { x: 0, y: 0 };
    this.targetVelocity = { x: 0, y: 0 };
    this.acceleration = 0.1;
    
    // Behavior state
    this.state = 'flying'; // flying, resting, fleeing, alert
    this.stateTimer = 0;
    this.restChance = 0.003;
    this.restDuration = 800 + Math.random() * 1500;
    this.directionChangeTimer = 0;
    this.directionChangeInterval = 500 + Math.random() * 1000;
    
    // Threat detection (flies react to fast movement)
    this.alertDistance = 150;
    this.reactionTime = 100 + Math.random() * 100; // 100-200ms
    this.pendingThreat = null;
    this.threatTimer = 0;
    
    // Wing animation
    this.wingTime = 0;
    
    this.pickNewDirection();
  }
  
  get x() { return this.container.x; }
  get y() { return this.container.y; }
  set x(val) { this.container.x = val; }
  set y(val) { this.container.y = val; }
  
  pickNewDirection() {
    const angle = Math.random() * Math.PI * 2;
    const speed = this.maxSpeed * (0.5 + Math.random() * 0.5);
    this.targetVelocity.x = Math.cos(angle) * speed;
    this.targetVelocity.y = Math.sin(angle) * speed;
    this.directionChangeInterval = 500 + Math.random() * 1500;
    this.directionChangeTimer = 0;
  }
  
  // Called when something fast moves near the fly
  detectThreat(x, y, speed) {
    if (this.state === 'fleeing') return;
    
    const dist = Phaser.Math.Distance.Between(this.x, this.y, x, y);
    
    // Only react to fast-moving threats within alert distance
    if (dist < this.alertDistance && speed > 5) {
      this.pendingThreat = { x, y };
      this.threatTimer = this.reactionTime;
      this.state = 'alert';
    }
  }
  
  fleeFrom(x, y) {
    // Fly away from the threat (opposite direction)
    const dx = this.container.x - x;
    const dy = this.container.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 0) {
      // Flee at maximum speed
      this.targetVelocity.x = (dx / dist) * this.maxSpeed * 2;
      this.targetVelocity.y = (dy / dist) * this.maxSpeed * 2;
      // Immediate velocity boost
      this.velocity.x = this.targetVelocity.x * 0.5;
      this.velocity.y = this.targetVelocity.y * 0.5;
    }
    
    this.state = 'fleeing';
    this.stateTimer = 600 + Math.random() * 400;
    this.pendingThreat = null;
  }
  
  update(delta) {
    if (!this.alive) return;
    
    // Wing animation (faster when fleeing)
    const wingSpeed = this.state === 'fleeing' ? 0.08 : 0.05;
    this.wingTime += delta * wingSpeed;
    const wingFlap = Math.sin(this.wingTime) * 15;
    this.leftWing.setAngle(-20 + wingFlap);
    this.rightWing.setAngle(20 - wingFlap);
    
    // State management
    this.stateTimer -= delta;
    this.directionChangeTimer += delta;
    
    // Process pending threat reaction
    if (this.state === 'alert') {
      this.threatTimer -= delta;
      if (this.threatTimer <= 0 && this.pendingThreat) {
        this.fleeFrom(this.pendingThreat.x, this.pendingThreat.y);
      }
      return;
    }
    
    if (this.state === 'resting') {
      this.leftWing.setAngle(-10);
      this.rightWing.setAngle(10);
      
      if (this.stateTimer <= 0) {
        this.state = 'flying';
        this.pickNewDirection();
      }
      return;
    }
    
    if (this.state === 'fleeing' && this.stateTimer <= 0) {
      this.state = 'flying';
      this.pickNewDirection();
    }
    
    // Random rest (flies land occasionally)
    if (this.state === 'flying' && Math.random() < this.restChance) {
      this.state = 'resting';
      this.stateTimer = this.restDuration;
      this.velocity.x *= 0.1;
      this.velocity.y *= 0.1;
      return;
    }
    
    // Direction changes
    if (this.state === 'flying' && this.directionChangeTimer >= this.directionChangeInterval) {
      this.pickNewDirection();
    }
    
    // Smooth acceleration toward target velocity
    const accel = this.state === 'fleeing' ? 0.2 : 0.1;
    this.velocity.x += (this.targetVelocity.x - this.velocity.x) * accel;
    this.velocity.y += (this.targetVelocity.y - this.velocity.y) * accel;
    
    // Apply velocity
    this.container.x += this.velocity.x;
    this.container.y += this.velocity.y;
    
    // Bounce off walls
    const margin = 30;
    if (this.container.x < margin) {
      this.container.x = margin;
      this.targetVelocity.x = Math.abs(this.targetVelocity.x) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.x > CONFIG.width - margin) {
      this.container.x = CONFIG.width - margin;
      this.targetVelocity.x = -Math.abs(this.targetVelocity.x) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.y < margin + 80) {
      this.container.y = margin + 80;
      this.targetVelocity.y = Math.abs(this.targetVelocity.y) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.y > CONFIG.height - margin - 200) {
      this.container.y = CONFIG.height - margin - 200;
      this.targetVelocity.y = -Math.abs(this.targetVelocity.y) * (0.8 + Math.random() * 0.4);
    }
    
    // Face direction of movement
    if (Math.abs(this.velocity.x) > 0.1) {
      this.container.scaleX = this.velocity.x > 0 ? 1 : -1;
    }
  }
  
  kill() {
    this.alive = false;
    
    this.scene.tweens.add({
      targets: this.container,
      scaleX: 1.5,
      scaleY: 0.3,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        this.container.destroy();
      }
    });
  }
}

// ============================================
// RUBBER BAND PROJECTILE
// ============================================
class RubberBandProjectile {
  constructor(scene, x, y, velocityX, velocityY) {
    this.scene = scene;
    this.active = true;
    this.speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
    
    // Create projectile graphic (rubber band ball)
    this.sprite = scene.add.circle(x, y, 8, 0x8B4513);
    this.sprite.setStrokeStyle(2, 0x5D3A1A);
    
    this.velocity = { x: velocityX, y: velocityY };
    this.gravity = 0.15; // Gravity effect
    
    // Trail effect
    this.trail = [];
  }
  
  update(delta) {
    if (!this.active) return;
    
    // Store trail position
    this.trail.push({ x: this.sprite.x, y: this.sprite.y, alpha: 0.5 });
    if (this.trail.length > 5) {
      this.trail.shift();
    }
    
    // Apply gravity (more effect on slow shots)
    const gravityFactor = Math.max(0.5, 1 - (this.speed / 30));
    this.velocity.y += this.gravity * gravityFactor;
    
    // Apply velocity
    this.sprite.x += this.velocity.x;
    this.sprite.y += this.velocity.y;
    
    // Check bounds
    if (this.sprite.x < 0 || this.sprite.x > CONFIG.width ||
        this.sprite.y < 0 || this.sprite.y > CONFIG.height) {
      this.destroy();
    }
  }
  
  getSpeed() {
    return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
  }
  
  destroy() {
    this.active = false;
    this.scene.tweens.add({
      targets: this.sprite,
      alpha: 0,
      scale: 0.5,
      duration: 100,
      onComplete: () => this.sprite.destroy()
    });
  }
}

// ============================================
// GAME SCENE
// ============================================
class GameScene extends Phaser.Scene {
  constructor() {
    super({ key: 'GameScene' });
  }
  
  init(data) {
    this.currentLevel = data.level || 1;
    this.levelConfig = LEVELS[this.currentLevel];
  }
  
  create() {
    // Background
    this.add.rectangle(CONFIG.width/2, CONFIG.height/2, CONFIG.width, CONFIG.height, 0xf5f5dc);
    this.add.rectangle(CONFIG.width/2, CONFIG.height - 30, CONFIG.width, 60, 0x8b7355);
    this.add.rectangle(CONFIG.width/2, 30, CONFIG.width, 60, 0xe8e0d0);
    
    // Window (decorative)
    this.add.rectangle(CONFIG.width/2, 200, 120, 150, 0x87ceeb);
    this.add.rectangle(CONFIG.width/2, 200, 110, 140, 0xadd8e6);
    this.add.rectangle(CONFIG.width/2, 200, 4, 150, 0x8b7355);
    this.add.rectangle(CONFIG.width/2, 200, 120, 4, 0x8b7355);
    
    // Game state
    this.score = 0;
    this.combo = 0;
    this.comboTimer = 0;
    this.catches = 0;
    this.misses = 0;
    this.flies = [];
    this.gameActive = true;
    this.timeRemaining = this.levelConfig.timeLimit;
    
    // Rubber band specific
    this.projectile = null;
    this.isDragging = false;
    this.dragStart = { x: 0, y: 0 };
    this.anchorPoint = { x: CONFIG.width / 2, y: CONFIG.height - 180 };
    this.aimLine = null;
    this.powerIndicator = null;
    
    // UI Setup
    this.createUI();
    
    // Tool-specific setup
    if (this.levelConfig.tool === 'swatter') {
      this.setupSwatter();
    } else if (this.levelConfig.tool === 'rubberband') {
      this.setupRubberBand();
    }
    
    // Spawn first fly
    this.spawnFly();
    
    // Timer
    this.timerEvent = this.time.addEvent({
      delay: 1000,
      callback: this.updateTimer,
      callbackScope: this,
      loop: true
    });
  }
  
  createUI() {
    // Level name
    this.add.text(CONFIG.width/2, 15, `Level ${this.currentLevel}: ${this.levelConfig.name}`, {
      fontSize: '16px',
      fontFamily: 'Arial, sans-serif',
      color: '#666',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0);
    
    // Timer
    this.timerText = this.add.text(CONFIG.width/2, 45, this.formatTime(this.timeRemaining), {
      fontSize: '32px',
      fontFamily: 'Arial, sans-serif',
      color: '#333',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0);
    
    // Progress (catches)
    this.progressText = this.add.text(20, 85, `Catches: 0/${this.levelConfig.targetCatches}`, {
      fontSize: '18px',
      fontFamily: 'Arial, sans-serif',
      color: '#333'
    });
    
    // Score
    this.scoreText = this.add.text(CONFIG.width - 20, 85, 'Score: 0', {
      fontSize: '18px',
      fontFamily: 'Arial, sans-serif',
      color: '#333'
    }).setOrigin(1, 0);
    
    // Combo
    this.comboText = this.add.text(CONFIG.width/2, 120, '', {
      fontSize: '24px',
      fontFamily: 'Arial, sans-serif',
      color: '#e74c3c',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0);
  }
  
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${secs}s`;
  }
  
  updateTimer() {
    if (!this.gameActive) return;
    
    this.timeRemaining--;
    this.timerText.setText(this.formatTime(this.timeRemaining));
    
    // Flash red when low
    if (this.timeRemaining <= 5) {
      this.timerText.setColor('#e74c3c');
      this.tweens.add({
        targets: this.timerText,
        scale: 1.2,
        duration: 100,
        yoyo: true
      });
    }
    
    if (this.timeRemaining <= 0) {
      this.endGame(false);
    }
  }
  
  // ============================================
  // SWATTER TOOL
  // ============================================
  setupSwatter() {
    this.swatter = this.createSwatter();
    this.swatter.setVisible(false);
    this.swatter.setDepth(100);
    
    this.input.on('pointermove', this.handleSwatterMove, this);
    this.input.on('pointerdown', this.handleSwatterTap, this);
  }
  
  createSwatter() {
    const swatter = this.add.container(0, 0);
    
    const handle = this.add.rectangle(0, 70, 12, 100, 0x8B4513);
    handle.setStrokeStyle(2, 0x5D3A1A);
    
    const head = this.add.ellipse(0, 0, 80, 90, 0x222222);
    head.setStrokeStyle(3, 0x111111);
    
    const meshGraphics = this.add.graphics();
    meshGraphics.lineStyle(1, 0x444444, 0.8);
    
    for (let y = -35; y <= 35; y += 10) {
      const width = Math.sqrt(1 - (y/45)**2) * 38;
      meshGraphics.lineBetween(-width, y, width, y);
    }
    
    for (let x = -35; x <= 35; x += 10) {
      const height = Math.sqrt(1 - (x/40)**2) * 42;
      meshGraphics.lineBetween(x, -height, x, height);
    }
    
    swatter.add([handle, head, meshGraphics]);
    swatter.setScale(0.7);
    
    return swatter;
  }
  
  handleSwatterMove(pointer) {
    this.swatter.setPosition(pointer.x, pointer.y);
    this.swatter.setVisible(true);
    this.swatter.setAngle(-15);
  }
  
  handleSwatterTap(pointer) {
    if (!this.gameActive) return;
    
    const tapX = pointer.x;
    const tapY = pointer.y;
    
    // Animate swatter
    this.swatter.setPosition(tapX, tapY);
    this.tweens.add({
      targets: this.swatter,
      angle: 15,
      duration: 50,
      yoyo: true,
      ease: 'Power2'
    });
    
    // Check for hits
    let hitAny = false;
    
    this.flies.forEach(fly => {
      if (!fly.alive) return;
      
      const distance = Phaser.Math.Distance.Between(tapX, tapY, fly.x, fly.y);
      
      if (distance < this.levelConfig.hitRadius) {
        hitAny = true;
        this.catchFly(fly, tapX, tapY, 1);
      } else if (distance < this.levelConfig.hitRadius * 2) {
        fly.fleeFrom(tapX, tapY);
      }
    });
    
    if (!hitAny) {
      this.handleMiss();
    }
  }
  
  // ============================================
  // RUBBER BAND TOOL
  // ============================================
  setupRubberBand() {
    // Anchor point visual
    this.anchorVisual = this.add.container(this.anchorPoint.x, this.anchorPoint.y);
    
    // Slingshot frame
    const leftPost = this.add.rectangle(-25, -20, 8, 50, 0x8B4513);
    const rightPost = this.add.rectangle(25, -20, 8, 50, 0x8B4513);
    const base = this.add.rectangle(0, 10, 60, 12, 0x5D3A1A);
    
    this.anchorVisual.add([base, leftPost, rightPost]);
    
    // Rubber band graphics (will be drawn dynamically)
    this.bandGraphics = this.add.graphics();
    this.bandGraphics.setDepth(50);
    
    // Power meter background
    this.powerMeterBg = this.add.rectangle(CONFIG.width - 30, CONFIG.height/2, 20, 200, 0x333333, 0.3);
    this.powerMeterFill = this.add.rectangle(CONFIG.width - 30, CONFIG.height/2 + 100, 16, 0, 0xe74c3c);
    this.powerMeterFill.setOrigin(0.5, 1);
    
    // Trajectory preview
    this.trajectoryGraphics = this.add.graphics();
    this.trajectoryGraphics.setDepth(40);
    
    // Instructions
    this.instructionText = this.add.text(CONFIG.width/2, CONFIG.height - 120, 'Touch below & pull back to aim!', {
      fontSize: '14px',
      fontFamily: 'Arial, sans-serif',
      color: '#666'
    }).setOrigin(0.5);
    
    // Input handlers
    this.input.on('pointerdown', this.handleRubberBandStart, this);
    this.input.on('pointermove', this.handleRubberBandDrag, this);
    this.input.on('pointerup', this.handleRubberBandRelease, this);
  }
  
  handleRubberBandStart(pointer) {
    if (!this.gameActive || this.projectile) return;
    
    // Larger touch area for mobile - anywhere in bottom third of screen
    if (pointer.y > CONFIG.height - 300) {
      this.isDragging = true;
      this.dragStart = { x: pointer.x, y: pointer.y };
    }
  }
  
  handleRubberBandDrag(pointer) {
    if (!this.isDragging || !this.gameActive) return;
    
    // Calculate pull vector (from pointer back to anchor)
    const pullX = this.anchorPoint.x - pointer.x;
    const pullY = this.anchorPoint.y - pointer.y;
    const pullDistance = Math.min(Math.sqrt(pullX * pullX + pullY * pullY), 150);
    const pullAngle = Math.atan2(pullY, pullX);
    
    // Constrain pull point
    const constrainedX = this.anchorPoint.x - Math.cos(pullAngle) * pullDistance;
    const constrainedY = this.anchorPoint.y - Math.sin(pullAngle) * pullDistance;
    
    // Draw rubber band
    this.bandGraphics.clear();
    this.bandGraphics.lineStyle(4, 0x8B4513);
    
    // Left band
    this.bandGraphics.lineBetween(
      this.anchorPoint.x - 25, this.anchorPoint.y - 40,
      constrainedX, constrainedY
    );
    
    // Right band
    this.bandGraphics.lineBetween(
      this.anchorPoint.x + 25, this.anchorPoint.y - 40,
      constrainedX, constrainedY
    );
    
    // Projectile preview at pull point
    this.bandGraphics.fillStyle(0x8B4513);
    this.bandGraphics.fillCircle(constrainedX, constrainedY, 10);
    
    // Update power meter
    const power = pullDistance / 150;
    this.powerMeterFill.setSize(16, power * 196);
    
    // Color based on power
    if (power < 0.3) {
      this.powerMeterFill.setFillStyle(0xf39c12); // Orange - weak
    } else if (power < 0.7) {
      this.powerMeterFill.setFillStyle(0x27ae60); // Green - good
    } else {
      this.powerMeterFill.setFillStyle(0xe74c3c); // Red - powerful
    }
    
    // Draw trajectory preview
    this.drawTrajectory(constrainedX, constrainedY, pullDistance, pullAngle);
    
    // Alert flies to the pulling motion (slow, so low threat)
    this.flies.forEach(fly => fly.detectThreat(constrainedX, constrainedY, 2));
  }
  
  drawTrajectory(startX, startY, power, angle) {
    this.trajectoryGraphics.clear();
    this.trajectoryGraphics.lineStyle(2, 0x333333, 0.3);
    
    const velocityMagnitude = power * 0.2;
    let vx = Math.cos(angle) * velocityMagnitude * 60;
    let vy = Math.sin(angle) * velocityMagnitude * 60;
    
    let x = startX;
    let y = startY;
    
    const points = [{ x, y }];
    const gravityFactor = Math.max(0.5, 1 - (power / 150));
    
    for (let i = 0; i < 30; i++) {
      vy += 0.15 * gravityFactor;
      x += vx * 0.5;
      y += vy * 0.5;
      
      if (y > CONFIG.height || x < 0 || x > CONFIG.width) break;
      points.push({ x, y });
    }
    
    // Draw dotted line
    for (let i = 0; i < points.length - 1; i += 2) {
      if (points[i + 1]) {
        this.trajectoryGraphics.lineBetween(
          points[i].x, points[i].y,
          points[i + 1].x, points[i + 1].y
        );
      }
    }
  }
  
  handleRubberBandRelease(pointer) {
    if (!this.isDragging || !this.gameActive) return;
    
    this.isDragging = false;
    
    // Calculate launch velocity
    const pullX = this.anchorPoint.x - pointer.x;
    const pullY = this.anchorPoint.y - pointer.y;
    const pullDistance = Math.min(Math.sqrt(pullX * pullX + pullY * pullY), 150);
    
    if (pullDistance < 20) {
      // Not enough pull, cancel
      this.bandGraphics.clear();
      this.trajectoryGraphics.clear();
      this.powerMeterFill.setSize(16, 0);
      return;
    }
    
    const pullAngle = Math.atan2(pullY, pullX);
    const velocityMagnitude = pullDistance * 0.2;
    
    const vx = Math.cos(pullAngle) * velocityMagnitude;
    const vy = Math.sin(pullAngle) * velocityMagnitude;
    
    // Create projectile
    const startX = this.anchorPoint.x - Math.cos(pullAngle) * pullDistance;
    const startY = this.anchorPoint.y - Math.sin(pullAngle) * pullDistance;
    
    this.projectile = new RubberBandProjectile(this, startX, startY, vx, vy);
    
    // Clear visuals
    this.bandGraphics.clear();
    this.trajectoryGraphics.clear();
    this.powerMeterFill.setSize(16, 0);
    
    // Animate slingshot snap
    this.tweens.add({
      targets: this.anchorVisual,
      scaleX: 1.1,
      duration: 50,
      yoyo: true
    });
  }
  
  // ============================================
  // COMMON GAME METHODS
  // ============================================
  spawnFly() {
    const margin = 50;
    const x = margin + Math.random() * (CONFIG.width - margin * 2);
    const y = 120 + Math.random() * (CONFIG.height - 400);
    
    const fly = new Fly(this, x, y, this.levelConfig.flySpeed);
    this.flies.push(fly);
  }
  
  catchFly(fly, hitX, hitY, speedBonus) {
    fly.kill();
    this.catches++;
    
    // Show splat
    this.showSplatEffect(fly.x, fly.y);
    
    // Update combo
    this.combo++;
    this.comboTimer = 2000;
    
    // Calculate score
    const basePoints = 100;
    const comboMultiplier = Math.min(this.combo, 10);
    const velocityBonus = speedBonus > 1.5 ? 50 : 0; // Bonus for powerful hits
    const points = (basePoints + velocityBonus) * comboMultiplier;
    this.score += points;
    
    // Update UI
    this.scoreText.setText(`Score: ${this.score}`);
    this.progressText.setText(`Catches: ${this.catches}/${this.levelConfig.targetCatches}`);
    
    if (this.combo > 1) {
      this.comboText.setText(`${this.combo}x COMBO!`);
      this.tweens.add({
        targets: this.comboText,
        scale: 1.2,
        duration: 100,
        yoyo: true
      });
    }
    
    // Velocity bonus popup
    if (velocityBonus > 0) {
      this.showBonusPopup(fly.x, fly.y - 30, 'POWER HIT!');
    }
    
    this.showPointsPopup(fly.x, fly.y, points, this.combo);
    
    // Screen effects
    this.cameras.main.shake(100, 0.01);
    this.cameras.main.flash(100, 255, 255, 255, false);
    
    // Remove from array
    this.flies = this.flies.filter(f => f !== fly);
    
    // Check win condition
    if (this.catches >= this.levelConfig.targetCatches) {
      this.endGame(true);
      return;
    }
    
    // Spawn new fly
    this.time.delayedCall(300, () => {
      if (this.flies.length < this.levelConfig.maxFlies && this.gameActive) {
        this.spawnFly();
      }
    });
  }
  
  showSplatEffect(x, y) {
    const splat = this.add.container(x, y);
    
    const mainSplat = this.add.circle(0, 0, 15, 0x333333, 0.6);
    splat.add(mainSplat);
    
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const dist = 15 + Math.random() * 15;
      const dotX = Math.cos(angle) * dist;
      const dotY = Math.sin(angle) * dist;
      const dot = this.add.circle(dotX, dotY, 3 + Math.random() * 4, 0x333333, 0.5);
      splat.add(dot);
    }
    
    this.tweens.add({
      targets: splat,
      alpha: 0,
      duration: 2000,
      delay: 500,
      onComplete: () => splat.destroy()
    });
  }
  
  showPointsPopup(x, y, points, combo) {
    const color = combo > 1 ? '#e74c3c' : '#27ae60';
    const text = combo > 1 ? `+${points}` : `+${points}`;
    
    const popup = this.add.text(x, y, text, {
      fontSize: combo > 1 ? '28px' : '24px',
      fontFamily: 'Arial, sans-serif',
      color: color,
      fontStyle: 'bold',
      stroke: '#fff',
      strokeThickness: 3
    }).setOrigin(0.5);
    
    this.tweens.add({
      targets: popup,
      y: y - 60,
      alpha: 0,
      scale: 1.3,
      duration: 600,
      ease: 'Power2',
      onComplete: () => popup.destroy()
    });
  }
  
  showBonusPopup(x, y, text) {
    const popup = this.add.text(x, y, text, {
      fontSize: '20px',
      fontFamily: 'Arial, sans-serif',
      color: '#f39c12',
      fontStyle: 'bold',
      stroke: '#fff',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    this.tweens.add({
      targets: popup,
      y: y - 40,
      alpha: 0,
      duration: 800,
      onComplete: () => popup.destroy()
    });
  }
  
  handleMiss() {
    this.misses++;
    this.combo = 0;
    this.comboTimer = 0;
    this.comboText.setText('');
  }
  
  endGame(won) {
    this.gameActive = false;
    if (this.timerEvent) this.timerEvent.remove();
    
    // Delay before showing result
    this.time.delayedCall(500, () => {
      this.scene.start('ResultScene', {
        won: won,
        level: this.currentLevel,
        score: this.score,
        catches: this.catches,
        target: this.levelConfig.targetCatches,
        timeRemaining: this.timeRemaining
      });
    });
  }
  
  update(time, delta) {
    // Update flies
    this.flies.forEach(fly => fly.update(delta));
    
    // Update projectile (rubber band mode)
    if (this.projectile && this.projectile.active) {
      this.projectile.update(delta);
      
      // Check collision with flies
      this.flies.forEach(fly => {
        if (!fly.alive || !this.projectile.active) return;
        
        const dist = Phaser.Math.Distance.Between(
          this.projectile.sprite.x, this.projectile.sprite.y,
          fly.x, fly.y
        );
        
        // Alert fly to fast-moving projectile
        fly.detectThreat(this.projectile.sprite.x, this.projectile.sprite.y, this.projectile.getSpeed());
        
        if (dist < this.levelConfig.hitRadius + 10) {
          // Hit! Speed bonus for powerful shots
          const speedBonus = this.projectile.getSpeed() / 10;
          this.catchFly(fly, this.projectile.sprite.x, this.projectile.sprite.y, speedBonus);
          this.projectile.destroy();
          this.projectile = null;
        }
      });
      
      // Projectile out of bounds
      if (this.projectile && !this.projectile.active) {
        this.projectile = null;
        this.handleMiss();
      }
    }
    
    // Clean up destroyed projectile
    if (this.projectile && !this.projectile.active) {
      this.projectile = null;
    }
    
    // Update combo timer
    if (this.comboTimer > 0) {
      this.comboTimer -= delta;
      if (this.comboTimer <= 0) {
        this.combo = 0;
        this.comboText.setText('');
      }
    }
  }
}

// ============================================
// RESULT SCENE
// ============================================
class ResultScene extends Phaser.Scene {
  constructor() {
    super({ key: 'ResultScene' });
  }
  
  init(data) {
    this.won = data.won;
    this.level = data.level;
    this.score = data.score;
    this.catches = data.catches;
    this.target = data.target;
    this.timeRemaining = data.timeRemaining;
  }
  
  create() {
    this.add.rectangle(CONFIG.width/2, CONFIG.height/2, CONFIG.width, CONFIG.height, 0x1a1a2e);
    
    // Result header
    const headerText = this.won ? 'LEVEL COMPLETE!' : 'TIME\'S UP!';
    const headerColor = this.won ? '#27ae60' : '#e74c3c';
    
    this.add.text(CONFIG.width/2, 150, headerText, {
      fontSize: '36px',
      fontFamily: 'Arial, sans-serif',
      color: headerColor,
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    // Stats
    this.add.text(CONFIG.width/2, 250, `Catches: ${this.catches}/${this.target}`, {
      fontSize: '24px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff'
    }).setOrigin(0.5);
    
    this.add.text(CONFIG.width/2, 300, `Score: ${this.score}`, {
      fontSize: '28px',
      fontFamily: 'Arial, sans-serif',
      color: '#f39c12',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    if (this.won && this.timeRemaining > 0) {
      this.add.text(CONFIG.width/2, 350, `Time Bonus: +${this.timeRemaining * 10}`, {
        fontSize: '20px',
        fontFamily: 'Arial, sans-serif',
        color: '#3498db'
      }).setOrigin(0.5);
    }
    
    // Buttons
    const buttonY = 480;
    
    if (this.won && LEVELS[this.level + 1]) {
      // Next Level button
      const nextBtn = this.add.rectangle(CONFIG.width/2, buttonY, 200, 50, 0x27ae60)
        .setInteractive({ useHandCursor: true });
      
      this.add.text(CONFIG.width/2, buttonY, 'NEXT LEVEL', {
        fontSize: '22px',
        fontFamily: 'Arial, sans-serif',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      nextBtn.on('pointerover', () => nextBtn.setFillStyle(0x2ecc71));
      nextBtn.on('pointerout', () => nextBtn.setFillStyle(0x27ae60));
      nextBtn.on('pointerdown', () => {
        this.scene.start('GameScene', { level: this.level + 1 });
      });
    }
    
    // Retry button
    const retryY = this.won && LEVELS[this.level + 1] ? buttonY + 70 : buttonY;
    const retryBtn = this.add.rectangle(CONFIG.width/2, retryY, 200, 50, 0x3498db)
      .setInteractive({ useHandCursor: true });
    
    this.add.text(CONFIG.width/2, retryY, 'RETRY', {
      fontSize: '22px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    retryBtn.on('pointerover', () => retryBtn.setFillStyle(0x5dade2));
    retryBtn.on('pointerout', () => retryBtn.setFillStyle(0x3498db));
    retryBtn.on('pointerdown', () => {
      this.scene.start('GameScene', { level: this.level });
    });
    
    // Menu button
    const menuBtn = this.add.rectangle(CONFIG.width/2, retryY + 70, 200, 50, 0x95a5a6)
      .setInteractive({ useHandCursor: true });
    
    this.add.text(CONFIG.width/2, retryY + 70, 'MENU', {
      fontSize: '22px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    menuBtn.on('pointerover', () => menuBtn.setFillStyle(0xbdc3c7));
    menuBtn.on('pointerout', () => menuBtn.setFillStyle(0x95a5a6));
    menuBtn.on('pointerdown', () => {
      this.scene.start('MenuScene');
    });
  }
}

// ============================================
// MENU SCENE
// ============================================
class MenuScene extends Phaser.Scene {
  constructor() {
    super({ key: 'MenuScene' });
  }
  
  create() {
    this.add.rectangle(CONFIG.width/2, CONFIG.height/2, CONFIG.width, CONFIG.height, 0x1a1a2e);
    
    // Title
    this.add.text(CONFIG.width/2, 150, 'ðŸª°', {
      fontSize: '80px'
    }).setOrigin(0.5);
    
    this.add.text(CONFIG.width/2, 250, 'FLY CATCHER', {
      fontSize: '42px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    // Level buttons
    let btnY = 380;
    
    Object.keys(LEVELS).forEach(levelNum => {
      const level = LEVELS[levelNum];
      
      const btn = this.add.rectangle(CONFIG.width/2, btnY, 280, 60, 0x27ae60)
        .setInteractive({ useHandCursor: true });
      
      this.add.text(CONFIG.width/2, btnY - 8, `Level ${levelNum}: ${level.name}`, {
        fontSize: '20px',
        fontFamily: 'Arial, sans-serif',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      this.add.text(CONFIG.width/2, btnY + 14, level.instructions, {
        fontSize: '12px',
        fontFamily: 'Arial, sans-serif',
        color: '#ccc'
      }).setOrigin(0.5);
      
      btn.on('pointerover', () => btn.setFillStyle(0x2ecc71));
      btn.on('pointerout', () => btn.setFillStyle(0x27ae60));
      btn.on('pointerdown', () => {
        this.scene.start('GameScene', { level: parseInt(levelNum) });
      });
      
      btnY += 90;
    });
  }
}

// ============================================
// GAME CONFIG
// ============================================
const config = {
  type: Phaser.AUTO,
  width: CONFIG.width,
  height: CONFIG.height,
  parent: 'game-container',
  backgroundColor: '#1a1a2e',
  scene: [MenuScene, GameScene, ResultScene],
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
};

const game = new Phaser.Game(config);
  </script>
</body>
</html>
