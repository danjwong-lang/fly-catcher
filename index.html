<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fly Catcher</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    #game-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <script>
// ============================================
// FLY CATCHER - MVP
// ============================================

const CONFIG = {
  width: 390,
  height: 700,
  flySpeed: 2.5,
  hitRadius: 100,
  comboTimeout: 2000,
  maxFlies: 1,
  spawnInterval: 3000
};

// Fly class with realistic movement
class Fly {
  constructor(scene, x, y) {
    this.scene = scene;
    this.alive = true;
    
    // Create fly graphics
    this.container = scene.add.container(x, y);
    
    // Body
    this.body = scene.add.ellipse(0, 0, 20, 14, 0x222222);
    
    // Wings
    this.leftWing = scene.add.ellipse(-8, -2, 14, 8, 0x88888888);
    this.rightWing = scene.add.ellipse(8, -2, 14, 8, 0x88888888);
    this.leftWing.setAngle(-20);
    this.rightWing.setAngle(20);
    
    // Eyes
    this.leftEye = scene.add.circle(-4, -4, 4, 0xcc0000);
    this.rightEye = scene.add.circle(4, -4, 4, 0xcc0000);
    
    this.container.add([this.leftWing, this.rightWing, this.body, this.leftEye, this.rightEye]);
    
    // Movement properties
    this.velocity = { x: 0, y: 0 };
    this.targetVelocity = { x: 0, y: 0 };
    this.acceleration = 0.1;
    this.maxSpeed = CONFIG.flySpeed;
    
    // Behavior state
    this.state = 'flying'; // flying, resting, fleeing
    this.stateTimer = 0;
    this.restChance = 0.005;
    this.restDuration = 500 + Math.random() * 1000;
    this.directionChangeTimer = 0;
    this.directionChangeInterval = 500 + Math.random() * 1000;
    
    // Wing animation
    this.wingTime = 0;
    
    this.pickNewDirection();
  }
  
  get x() { return this.container.x; }
  get y() { return this.container.y; }
  
  pickNewDirection() {
    const angle = Math.random() * Math.PI * 2;
    const speed = this.maxSpeed * (0.5 + Math.random() * 0.5);
    this.targetVelocity.x = Math.cos(angle) * speed;
    this.targetVelocity.y = Math.sin(angle) * speed;
    this.directionChangeInterval = 500 + Math.random() * 1500;
    this.directionChangeTimer = 0;
  }
  
  fleeFrom(x, y) {
    // Fly away from the tap point
    const dx = this.container.x - x;
    const dy = this.container.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 0) {
      this.targetVelocity.x = (dx / dist) * this.maxSpeed * 1.5;
      this.targetVelocity.y = (dy / dist) * this.maxSpeed * 1.5;
    }
    
    this.state = 'fleeing';
    this.stateTimer = 800;
  }
  
  update(delta) {
    if (!this.alive) return;
    
    // Wing animation
    this.wingTime += delta * 0.05;
    const wingFlap = Math.sin(this.wingTime) * 15;
    this.leftWing.setAngle(-20 + wingFlap);
    this.rightWing.setAngle(20 - wingFlap);
    
    // State management
    this.stateTimer -= delta;
    this.directionChangeTimer += delta;
    
    if (this.state === 'resting') {
      // Slow down wings while resting
      this.leftWing.setAngle(-10);
      this.rightWing.setAngle(10);
      
      if (this.stateTimer <= 0) {
        this.state = 'flying';
        this.pickNewDirection();
      }
      return;
    }
    
    if (this.state === 'fleeing' && this.stateTimer <= 0) {
      this.state = 'flying';
      this.pickNewDirection();
    }
    
    // Random rest
    if (this.state === 'flying' && Math.random() < this.restChance) {
      this.state = 'resting';
      this.stateTimer = this.restDuration;
      this.velocity.x *= 0.1;
      this.velocity.y *= 0.1;
      return;
    }
    
    // Direction changes
    if (this.state === 'flying' && this.directionChangeTimer >= this.directionChangeInterval) {
      this.pickNewDirection();
    }
    
    // Smooth acceleration toward target velocity
    this.velocity.x += (this.targetVelocity.x - this.velocity.x) * this.acceleration;
    this.velocity.y += (this.targetVelocity.y - this.velocity.y) * this.acceleration;
    
    // Apply velocity
    this.container.x += this.velocity.x;
    this.container.y += this.velocity.y;
    
    // Bounce off walls with some randomness
    const margin = 30;
    if (this.container.x < margin) {
      this.container.x = margin;
      this.targetVelocity.x = Math.abs(this.targetVelocity.x) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.x > CONFIG.width - margin) {
      this.container.x = CONFIG.width - margin;
      this.targetVelocity.x = -Math.abs(this.targetVelocity.x) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.y < margin + 60) { // Account for UI
      this.container.y = margin + 60;
      this.targetVelocity.y = Math.abs(this.targetVelocity.y) * (0.8 + Math.random() * 0.4);
    }
    if (this.container.y > CONFIG.height - margin) {
      this.container.y = CONFIG.height - margin;
      this.targetVelocity.y = -Math.abs(this.targetVelocity.y) * (0.8 + Math.random() * 0.4);
    }
    
    // Face direction of movement
    if (Math.abs(this.velocity.x) > 0.1) {
      this.container.scaleX = this.velocity.x > 0 ? 1 : -1;
    }
  }
  
  kill() {
    this.alive = false;
    
    // Death animation
    this.scene.tweens.add({
      targets: this.container,
      scaleX: 1.5,
      scaleY: 0.3,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        this.container.destroy();
      }
    });
  }
}

// Main game scene
class GameScene extends Phaser.Scene {
  constructor() {
    super({ key: 'GameScene' });
  }
  
  create() {
    // Background
    this.add.rectangle(CONFIG.width/2, CONFIG.height/2, CONFIG.width, CONFIG.height, 0xf5f5dc);
    
    // Add some environment details
    this.add.rectangle(CONFIG.width/2, CONFIG.height - 30, CONFIG.width, 60, 0x8b7355);
    this.add.rectangle(CONFIG.width/2, 30, CONFIG.width, 60, 0xe8e0d0);
    
    // Window (decorative)
    this.add.rectangle(CONFIG.width/2, 200, 120, 150, 0x87ceeb);
    this.add.rectangle(CONFIG.width/2, 200, 110, 140, 0xadd8e6);
    this.add.rectangle(CONFIG.width/2, 200, 4, 150, 0x8b7355);
    this.add.rectangle(CONFIG.width/2, 200, 120, 4, 0x8b7355);
    
    // Game state
    this.score = 0;
    this.combo = 0;
    this.comboTimer = 0;
    this.catches = 0;
    this.misses = 0;
    this.flies = [];
    this.gameActive = true;
    
    // UI - Score
    this.scoreText = this.add.text(20, 20, 'Score: 0', {
      fontSize: '24px',
      fontFamily: 'Arial, sans-serif',
      color: '#333',
      fontStyle: 'bold'
    });
    
    // UI - Combo
    this.comboText = this.add.text(CONFIG.width - 20, 20, '', {
      fontSize: '20px',
      fontFamily: 'Arial, sans-serif',
      color: '#e74c3c',
      fontStyle: 'bold'
    }).setOrigin(1, 0);
    
    // UI - Catches counter
    this.catchText = this.add.text(20, 50, 'Catches: 0', {
      fontSize: '16px',
      fontFamily: 'Arial, sans-serif',
      color: '#666'
    });
    
    // Fly swatter graphic
    this.swatter = this.createSwatter();
    this.swatter.setVisible(false);
    this.swatter.setDepth(100); // Always on top
    
    // Spawn first fly
    this.spawnFly();
    
    // Input handling
    this.input.on('pointerdown', this.handleTap, this);
    this.input.on('pointermove', this.handleMove, this);
    
    // Spawn timer for additional flies
    this.spawnTimer = this.time.addEvent({
      delay: CONFIG.spawnInterval,
      callback: this.maybeSpawnFly,
      callbackScope: this,
      loop: true
    });
  }
  
  createSwatter() {
    const swatter = this.add.container(0, 0);
    
    // Handle
    const handle = this.add.rectangle(0, 70, 12, 100, 0x8B4513);
    handle.setStrokeStyle(2, 0x5D3A1A);
    
    // Swatter head
    const head = this.add.ellipse(0, 0, 80, 90, 0x222222);
    head.setStrokeStyle(3, 0x111111);
    
    // Mesh pattern (grid lines)
    const meshGraphics = this.add.graphics();
    meshGraphics.lineStyle(1, 0x444444, 0.8);
    
    // Horizontal lines
    for (let y = -35; y <= 35; y += 10) {
      const width = Math.sqrt(1 - (y/45)**2) * 38;
      meshGraphics.lineBetween(-width, y, width, y);
    }
    
    // Vertical lines
    for (let x = -35; x <= 35; x += 10) {
      const height = Math.sqrt(1 - (x/40)**2) * 42;
      meshGraphics.lineBetween(x, -height, x, height);
    }
    
    swatter.add([handle, head, meshGraphics]);
    swatter.setScale(0.7);
    
    return swatter;
  }
  
  handleMove(pointer) {
    this.swatter.setPosition(pointer.x, pointer.y);
    this.swatter.setVisible(true);
    this.swatter.setAngle(-15); // Ready position
  }
  
  handleTap(pointer) {
    if (!this.gameActive) return;
    
    const tapX = pointer.x;
    const tapY = pointer.y;
    
    // Animate the swatter - quick swat motion
    this.swatter.setPosition(tapX, tapY);
    this.tweens.add({
      targets: this.swatter,
      angle: 15,
      duration: 50,
      yoyo: true,
      ease: 'Power2'
    });
    
    // Check for hits
    let hitAny = false;
    
    this.flies.forEach(fly => {
      if (!fly.alive) return;
      
      const distance = Phaser.Math.Distance.Between(tapX, tapY, fly.x, fly.y);
      
      if (distance < CONFIG.hitRadius) {
        // HIT!
        hitAny = true;
        this.catchFly(fly, tapX, tapY);
      } else if (distance < CONFIG.hitRadius * 2) {
        // Near miss - fly reacts
        fly.fleeFrom(tapX, tapY);
      }
    });
    
    if (!hitAny) {
      this.handleMiss();
    }
  }
  
  showTapEffect(x, y) {
    // Swat visual
    const swatCircle = this.add.circle(x, y, 10, 0x333333, 0.3);
    
    this.tweens.add({
      targets: swatCircle,
      radius: CONFIG.hitRadius,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => swatCircle.destroy()
    });
  }
  
  catchFly(fly, tapX, tapY) {
    fly.kill();
    this.catches++;
    
    // Show splat effect
    this.showSplatEffect(fly.x, fly.y);
    
    // Update combo
    this.combo++;
    this.comboTimer = CONFIG.comboTimeout;
    
    // Calculate score
    const basePoints = 100;
    const comboMultiplier = Math.min(this.combo, 10);
    const points = basePoints * comboMultiplier;
    this.score += points;
    
    // Update UI
    this.scoreText.setText(`Score: ${this.score}`);
    this.catchText.setText(`Catches: ${this.catches}`);
    
    if (this.combo > 1) {
      this.comboText.setText(`${this.combo}x COMBO!`);
      this.comboText.setScale(1.2);
      this.tweens.add({
        targets: this.comboText,
        scale: 1,
        duration: 200
      });
    }
    
    // Show points popup
    this.showPointsPopup(fly.x, fly.y, points, this.combo);
    
    // Screen shake for satisfaction
    this.cameras.main.shake(100, 0.01);
    
    // Flash effect
    this.cameras.main.flash(100, 255, 255, 255, false, null, this);
    
    // Remove from array
    this.flies = this.flies.filter(f => f !== fly);
    
    // Spawn new fly after short delay
    this.time.delayedCall(500, () => {
      if (this.flies.length < CONFIG.maxFlies) {
        this.spawnFly();
      }
    });
  }
  
  showSplatEffect(x, y) {
    // Splat marks
    const splat = this.add.container(x, y);
    
    // Main splat
    const mainSplat = this.add.circle(0, 0, 15, 0x333333, 0.6);
    splat.add(mainSplat);
    
    // Splatter dots
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const dist = 15 + Math.random() * 15;
      const dotX = Math.cos(angle) * dist;
      const dotY = Math.sin(angle) * dist;
      const dot = this.add.circle(dotX, dotY, 3 + Math.random() * 4, 0x333333, 0.5);
      splat.add(dot);
    }
    
    // Fade out over time
    this.tweens.add({
      targets: splat,
      alpha: 0,
      duration: 2000,
      delay: 500,
      onComplete: () => splat.destroy()
    });
  }
  
  showPointsPopup(x, y, points, combo) {
    const color = combo > 1 ? '#e74c3c' : '#27ae60';
    const text = combo > 1 ? `+${points} (${combo}x)` : `+${points}`;
    
    const popup = this.add.text(x, y, text, {
      fontSize: combo > 1 ? '28px' : '24px',
      fontFamily: 'Arial, sans-serif',
      color: color,
      fontStyle: 'bold',
      stroke: '#fff',
      strokeThickness: 3
    }).setOrigin(0.5);
    
    this.tweens.add({
      targets: popup,
      y: y - 60,
      alpha: 0,
      scale: 1.3,
      duration: 600,
      ease: 'Power2',
      onComplete: () => popup.destroy()
    });
  }
  
  handleMiss() {
    this.misses++;
    this.combo = 0;
    this.comboTimer = 0;
    this.comboText.setText('');
  }
  
  spawnFly() {
    const margin = 50;
    const x = margin + Math.random() * (CONFIG.width - margin * 2);
    const y = 100 + Math.random() * (CONFIG.height - 200);
    
    const fly = new Fly(this, x, y);
    this.flies.push(fly);
  }
  
  maybeSpawnFly() {
    if (this.flies.length < CONFIG.maxFlies) {
      this.spawnFly();
    }
  }
  
  update(time, delta) {
    // Update all flies
    this.flies.forEach(fly => fly.update(delta));
    
    // Update combo timer
    if (this.comboTimer > 0) {
      this.comboTimer -= delta;
      if (this.comboTimer <= 0) {
        this.combo = 0;
        this.comboText.setText('');
      }
    }
  }
}

// Menu scene
class MenuScene extends Phaser.Scene {
  constructor() {
    super({ key: 'MenuScene' });
  }
  
  create() {
    // Background
    this.add.rectangle(CONFIG.width/2, CONFIG.height/2, CONFIG.width, CONFIG.height, 0x1a1a2e);
    
    // Title
    this.add.text(CONFIG.width/2, 200, 'ðŸª°', {
      fontSize: '80px'
    }).setOrigin(0.5);
    
    this.add.text(CONFIG.width/2, 300, 'FLY CATCHER', {
      fontSize: '42px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    this.add.text(CONFIG.width/2, 360, 'Tap to swat the flies!', {
      fontSize: '18px',
      fontFamily: 'Arial, sans-serif',
      color: '#aaa'
    }).setOrigin(0.5);
    
    // Play button
    const playBtn = this.add.rectangle(CONFIG.width/2, 480, 200, 60, 0x27ae60, 1)
      .setInteractive({ useHandCursor: true });
    
    const playText = this.add.text(CONFIG.width/2, 480, 'PLAY', {
      fontSize: '28px',
      fontFamily: 'Arial, sans-serif',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    
    playBtn.on('pointerover', () => {
      playBtn.setFillStyle(0x2ecc71);
    });
    
    playBtn.on('pointerout', () => {
      playBtn.setFillStyle(0x27ae60);
    });
    
    playBtn.on('pointerdown', () => {
      this.scene.start('GameScene');
    });
    
    // Instructions
    this.add.text(CONFIG.width/2, 580, 'Build combos for bonus points!\nFlies flee from near misses.', {
      fontSize: '14px',
      fontFamily: 'Arial, sans-serif',
      color: '#666',
      align: 'center'
    }).setOrigin(0.5);
  }
}

// Phaser game config
const config = {
  type: Phaser.AUTO,
  width: CONFIG.width,
  height: CONFIG.height,
  parent: 'game-container',
  backgroundColor: '#1a1a2e',
  scene: [MenuScene, GameScene],
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
};

// Start game
const game = new Phaser.Game(config);
  </script>
</body>
</html>
